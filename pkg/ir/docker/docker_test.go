package docker

import (
	"encoding/json"
	"strings"
	"testing"
)

func TestRenderDockerfileCollapsesBlankLinesAfterContinuations(t *testing.T) {
	// Simulate a multi-line command generated by templates where packages are split
	// across lines with trailing backslashes and blank spacer lines between them.
	// The original bug caused these blank lines to survive into the Dockerfile,
	// so the shell treated each package as a standalone command (e.g. "-c"),
	// triggering "CondaValueError: missing package specifications".
	command := `conda install -y -q --name base \

    "-c" \

    "conda-forge" \

    "fsl-libvis"`

	if !strings.Contains(command, "\\\n\n") {
		t.Fatalf("test command must contain blank lines after continuations: %q", command)
	}

	df, err := RenderDockerfile([]Directive{
		From{Image: "ubuntu:22.04"},
		Run{Command: command},
	})
	if err != nil {
		t.Fatalf("RenderDockerfile() error = %v", err)
	}

	lines := strings.Split(df, "\n")
	var runLine string
	for _, line := range lines {
		if strings.HasPrefix(line, "RUN ") {
			runLine = strings.TrimPrefix(line, "RUN ")
			break
		}
	}
	if runLine == "" {
		t.Fatalf("generated Dockerfile missing RUN directive:\n%s", df)
	}

	var argv []string
	if err := json.Unmarshal([]byte(runLine), &argv); err != nil {
		t.Fatalf("decoding RUN exec form: %v\nraw line: %s", err, runLine)
	}
	if len(argv) != 3 {
		t.Fatalf("unexpected argv length %d (want 3) in RUN: %v", len(argv), argv)
	}

	cmd := argv[2]
	if strings.Contains(cmd, "\\\n\n") {
		t.Fatalf("shell command still contains blank line after continuation: %q", cmd)
	}

	if !strings.Contains(cmd, `"conda-forge"`) {
		t.Fatalf("expected sanitized command to retain package arguments, got: %q", cmd)
	}
}
